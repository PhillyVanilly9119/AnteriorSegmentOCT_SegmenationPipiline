# -*- coding: utf-8 -*-
"""
Created on Tue May 19 14:46:49 2020

@author: Philipp
"""

import os
import glob
import numpy as np
from PIL import Image 
import tensorflow as tf
import matplotlib.pyplot as plt
from tkinter.filedialog import askdirectory
from tensorflow import keras

# =============================================================================
# Thickness evaluation
# =============================================================================
def find_boundaries_in_mask(mask):
    size = np.shape(mask)
    for i in range(size[1]):
        if mask[1,i] is not True: #if cornea is not at bScan's upper corner
            pass
        elif mask[1,i] != 0: #if cornea exceeds bScan
            pass
    
    return pos_epi, pos_ovd

# =============================================================================
# Functionality
# =============================================================================
def predict_segmentation():
    network_path = r''
    load_pretrained_net(network_path)
    scans = load_data_from_folder()
    #b_scans = apply_trained_net()
    return scans 

def load_pretrained_net(): 
    """
    Loads and returns pre-trained network & its weights from *.h5-file
    """
    path = askdirectory(title='Please select directory with the network you want to use')
    model = keras.models.load_model(path)
    #TODO: return "Useable model" -> Maybe the weights?
    return model

model = load_pretrained_net()    

def apply_trained_net(model, scans, masks, main_path):
    """
    Predict and display segmented bScans -> Display to user
    """
    segmented_data = check_predicted_masks(scans, masks, main_path)
    
    return segmented_data

# =============================================================================
# load_pretrained_net(path_source, '20200519_model1', 'model')
# =============================================================================


def load_data_from_folder(dims=(1024,512)):
    """
    Primitive to load *.bmp-files of OCT b-Scans generated by ZEISS RESCAN
    """
    path = askdirectory(title='Please select data for segmentation')
    # check if path contains images
    assert any(fname.endswith('.bmp') for fname in os.listdir(path)), "Directory [DOES NOT CONTAIN ANY IMAGES] / *.BMP-files!"
    scan_list = glob.glob(os.path.join(path, "*.bmp"))
    # sort list after b-Scan #'s in image file names
    scan_list.sort(key=lambda f: int(''.join(filter(str.isdigit, f))))
    # Load (ONLY) b-Scans (with size = IMG_HEIGHT x IMG_WIDTH)
    scans = [np.asarray(Image.open(infile)) for infile in scan_list if np.shape(np.asarray(Image.open(infile))) == (dims[0],dims[1])]
    
    return np.dstack(scans)

def check_predicted_masks(scans, masks, main_path):
    """
    Sort and check if automatically segmented b-Scans were segemented correctly
    """
    path_good = os.path.join(main_path, 'CorrectScans')
    path_bad = os.path.join(main_path, 'IncorrectScans')
    assert scans.shape[2] != masks.shape[2], "Dimensions of data stacks do not match!"
    
    print("Please review automatically segmented images...")    
    for im in range(scans.shape[2]):
        plt.ion()
        plt.imshow(scans[:,:,im], 'gray', interpolation='none')
        plt.imshow(masks[:,:,im], 'jet', interpolation='none', alpha=0.65)
        mng = plt.get_current_fig_manager()
        mng.window.showMaximized()
        plt.show()
        key = input("Please press \"y\" if scan was segmented correctly and \"n\" if not")
        if key == 'y':
            plt.imsave(os.path.join(path_good, mask[:,:,im], str(im) + '.png'))
        elif key == 'n':
            plt.imsave(os.path.join(path_bad, mask[:,:,im], str(im) + '.png'))
        else:
            pass
            #raise ValueError("You\"ve hit the wrong key... Please enter either \"y\" or \"n\")
        plt.clf()
        
    print("Done displaying images!")